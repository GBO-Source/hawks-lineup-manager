<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hawks 503 Lineup Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fc; }
        /* Custom styles for drag-and-drop */
        .player-card {
            cursor: grab;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .player-card:active {
            cursor: grabbing;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 4, 18, 0.05);
            transform: scale(1.02);
        }
        .lineup-slot {
            min-height: 4rem; /* Ensure drop target is large enough */
            transition: background-color 0.15s, border-color 0.15s;
        }
        .drag-over {
            background-color: #e0f2fe !important; /* light-blue-100 */
            border-color: #3b82f6 !important; /* blue-500 */
        }
        
        /* New Color Coding based on Shot */
        .is-lh {
            /* This is the ORANGE tint for LH (Left Handed) shots */
            background-color: #fff7ed; /* Orange-100 */
            color: #c2410c; /* Orange-700 */
            border-color: #fb923c; /* Orange-400 */
        }
        .is-rh {
            /* This is the YELLOW tint for RH (Right Handed) shots */
            background-color: #fefce8; /* Yellow-100 */
            color: #a16207; /* Yellow-700 */
            border-color: #facc15; /* Yellow-400 */
        }
        /* UPDATED: Goalie card is now styled with RED colors */
        .is-goalie-type {
            background-color: #fef2f2; /* Red-50 */
            color: #b91c1c; /* Red-700 */
            border-color: #f87171; /* Red-400 */
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <!-- Header and App Management -->
    <header class="mb-8">
        <h1 class="text-4xl font-extrabold text-gray-900 mb-2">Hawks 503 Lineup Manager üèí</h1>
        <p class="text-lg text-gray-600">Build your lines using Name, Number, and Shot (LH/RH).</p>
    </header>

    <!-- Game Management & Roster Input -->
    <section class="bg-white p-6 rounded-xl shadow-lg mb-8">
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">Game & Roster Setup</h2>

        <div id="auth-info" class="text-sm text-gray-500 mb-4 flex justify-between items-center">
            <span id="user-id-display">Initializing...</span>
            <span id="app-id-display"></span>
        </div>

        <!-- Saved Games -->
        <div class="mb-4 flex flex-col md:flex-row md:items-center space-y-2 md:space-y-0 md:space-x-4">
            <label for="game-selector" class="font-medium text-gray-700">Load/New Game:</label>
            <select id="game-selector" class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500"></select>
            <button onclick="createNewGame()" class="bg-green-600 text-white p-2 rounded-lg hover:bg-green-700 transition duration-150 shadow-md whitespace-nowrap">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                </svg>
                New Game
            </button>
            <button onclick="saveGame()" class="bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M7 3a1 1 0 000 2h6a1 1 0 100-2H7z" />
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
                Save Lineup
            </button>
        </div>

        <!-- Roster CSV Input -->
        <div class="mt-6">
            <label for="csv-input" class="block font-medium text-gray-700 mb-1">Roster Data (Edit and click "Load Roster" to update):</label>
            <textarea id="csv-input" rows="8" placeholder="Example:&#10;Connor McDavid,97,RH&#10;Leon Draisaitl,29,LH&#10;..." class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-sm"></textarea>
            <button onclick="loadRosterFromCSV()" class="mt-2 bg-indigo-600 text-white p-2 rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md w-full">Load Roster</button>
        </div>
    </section>

    <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">

        <!-- Roster Panel (Source) -->
        <section class="lg:col-span-1 bg-white p-6 rounded-xl shadow-lg">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Available Roster (<span id="roster-count">0</span>)</h2>
            <div id="roster-list" class="space-y-2 max-h-[60vh] overflow-y-auto">
                <!-- Roster will be dynamically populated here. -->
            </div>
        </section>

        <!-- Lineup Panel (Target) -->
        <section class="lg:col-span-3 bg-white p-6 rounded-xl shadow-lg">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Current Lineup</h2>

            <!-- Forward Lines -->
            <h3 class="text-xl font-medium text-blue-800 mb-2 mt-4 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
                </svg>
                Forward Lines (4)
            </h3>
            <div id="forward-lines" class="space-y-4">
                <!-- Forward Lines will be rendered here -->
            </div>

            <!-- Defense Lines -->
            <h3 class="text-xl font-medium text-green-800 mb-2 mt-6 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
                Defense Pairings (3)
            </h3>
            <div id="defense-lines" class="space-y-4">
                <!-- Defense Lines will be rendered here -->
            </div>

            <!-- Goalie -->
            <h3 class="text-xl font-medium text-red-800 mb-2 mt-6 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
                </svg>
                Goalie (1)
            </h3>
            <div id="goalie-line" class="grid grid-cols-1 gap-4">
                <!-- Goalie will be rendered here -->
            </div>

        </section>
    </div>

    <!-- Message Modal -->
    <div id="message-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h3 id="modal-title" class="text-xl font-bold mb-3 text-gray-800"></h3>
            <p id="modal-message" class="mb-4 text-gray-600"></p>
            <button onclick="closeModal()" class="w-full bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition duration-150">Close</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set Firebase logging level to Debug
        setLogLevel('Debug');

        // --- GLOBAL VARIABLES & DEFAULT DATA ---

        // Default roster data in CSV format for easy modification in the textarea
        const DEFAULT_ROSTER_CSV = `
Ajay,19,RH
Ben,14,RH
Colson,9,RH
Fergus,8,LH
Frankie,7,RH
Griffin,15,RH
Halen,12,LH
Jack,11,RH
Jackson,17,LH
Jameson,5,RH
Jayden,18,LH
Jordon,6,RH
Keenan,13,LH
Lieven,1,LH
Oliver,4,RH
Rowan,2,RH
Sam,16,LH
`;

        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let app;
        let db;
        let auth;
        let userId = 'anon';
        let isAuthReady = false;

        // State Management
        let currentGameId = null;
        let allGames = []; // List of all saved games
        let masterRoster = []; // All players from CSV
        let availableRoster = []; // Players not currently in the lineup
        
        // Define lineup structure using role identifiers (not strict positions)
        let currentLineup = {
            forwards: Array(4).fill(null).map(() => ([
                {role: 'Left Forward', roleId: 'LF', player: null},
                {role: 'Center Forward', roleId: 'CF', player: null},
                {role: 'Right Forward', roleId: 'RF', player: null}
            ])),
            defense: Array(3).fill(null).map(() => ([
                {role: 'Left Defense', roleId: 'LD', player: null}, // LH Shot Preferred
                {role: 'Right Defense', roleId: 'RD', player: null} // RH Shot Preferred
            ])),
            goalie: {role: 'Goalie', roleId: 'G', player: null}
        };

        // DOM elements
        const rosterListEl = document.getElementById('roster-list');
        const rosterCountEl = document.getElementById('roster-count');
        const forwardLinesEl = document.getElementById('forward-lines');
        const defenseLinesEl = document.getElementById('defense-lines');
        const goalieLineEl = document.getElementById('goalie-line');
        const gameSelectorEl = document.getElementById('game-selector');
        const csvInputEl = document.getElementById('csv-input');


        // --- UTILITY & MODAL FUNCTIONS ---

        /**
         * Generates a simple UUID for player tracking.
         */
        const generateUUID = () => crypto.randomUUID();

        /**
         * Displays a custom modal message.
         * @param {string} title
         * @param {string} message
         */
        window.showModal = (title, message) => {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').textContent = message;
            document.getElementById('message-modal').classList.remove('hidden');
            document.getElementById('message-modal').classList.add('flex');
        };

        /**
         * Closes the custom modal.
         */
        window.closeModal = () => {
            document.getElementById('message-modal').classList.add('hidden');
            document.getElementById('message-modal').classList.remove('flex');
        };

        // --- FIREBASE INITIALIZATION & AUTH ---

        /**
         * Initializes Firebase and sets up authentication listener.
         */
        const initializeFirebase = async () => {
            if (!firebaseConfig) {
                console.error("Firebase config not available.");
                showModal("Configuration Error", "Firebase configuration is missing. Cannot save games.");
                loadRosterFromCSV(DEFAULT_ROSTER_CSV, true);
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                document.getElementById('app-id-display').textContent = `App ID: ${appId}`;

                // Sign in with custom token or anonymously
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                    console.log("Signed in with custom token.");
                } else {
                    await signInAnonymously(auth);
                    console.log("Signed in anonymously.");
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('user-id-display').textContent = `User ID: ${userId}`;
                        isAuthReady = true;
                        console.log("Auth state ready. User ID:", userId);
                        // Start listeners after auth is ready
                        setupGameListener();
                    } else {
                        userId = 'anon';
                        document.getElementById('user-id-display').textContent = `User ID: anon`;
                        isAuthReady = true;
                        setupGameListener(); // Still try to load default if offline
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase or signing in:", error);
                showModal("Firebase Error", "Failed to initialize Firebase or sign in. Check console for details. Loading default roster.");
                loadRosterFromCSV(DEFAULT_ROSTER_CSV, true);
            }
        };

        // --- GAME DATA MANAGEMENT (FIRESTORE) ---

        /**
         * Gets the collection reference for public game data.
         */
        const getGamesCollectionRef = () => {
            return collection(db, `artifacts/${appId}/public/data/hockey_lineups_shot`);
        };

        /**
         * Sets up the real-time listener for all saved games.
         */
        const setupGameListener = () => {
            if (!isAuthReady || !db) {
                // If Firebase didn't initialize, load default roster here
                if (masterRoster.length === 0) {
                    loadRosterFromCSV(DEFAULT_ROSTER_CSV, true);
                }
                return;
            }

            const gamesQuery = query(getGamesCollectionRef());

            onSnapshot(gamesQuery, (snapshot) => {
                allGames = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderGameSelector();
                console.log("Loaded all game templates:", allGames.length);

                if (allGames.length > 0) {
                    // Load the first saved game
                    if (!currentGameId) selectGame(allGames[0].id);
                } else {
                    // If no saved games, initialize with a new game and the default roster
                    createNewGame();
                    loadRosterFromCSV(DEFAULT_ROSTER_CSV, true); // Load default roster into the new game
                }
            }, (error) => {
                console.error("Error fetching games:", error);
                showModal("Data Error", "Failed to fetch saved games. Loading default roster.");
                loadRosterFromCSV(DEFAULT_ROSTER_CSV, true);
            });
        };

        /**
         * Saves the current lineup state to Firestore.
         */
        window.saveGame = async () => {
            if (!currentGameId || !isAuthReady || !db) {
                showModal("Save Error", "The app is not fully initialized. Please wait a moment and ensure you have parsed a roster and selected a game.");
                return;
            }

            const gameData = {
                id: currentGameId,
                name: document.getElementById('game-selector').querySelector(`option[value="${currentGameId}"]`).textContent,
                masterRoster: masterRoster,
                lineup: currentLineup,
                availableRoster: availableRoster,
                updatedAt: new Date().toISOString()
            };

            try {
                const gameDocRef = doc(db, `artifacts/${appId}/public/data/hockey_lineups_shot`, currentGameId);
                await setDoc(gameDocRef, gameData);
                showModal("Success!", `Lineup "${gameData.name}" saved successfully.`);
            } catch (error) {
                console.error("Error saving game:", error);
                showModal("Save Error", "Failed to save the lineup. Check console for details.");
            }
        };

        /**
         * Creates and selects a new, empty game template.
         */
        window.createNewGame = () => {
            const newGameId = generateUUID();
            const timestamp = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            const newGameName = `New Game - ${timestamp}`;

            // Reset state to a new, empty lineup but keep the current master roster data
            currentGameId = newGameId;
            currentLineup = {
                forwards: Array(4).fill(null).map(() => ([
                    {role: 'Left Forward', roleId: 'LF', player: null},
                    {role: 'Center Forward', roleId: 'CF', player: null},
                    {role: 'Right Forward', roleId: 'RF', player: null}
                ])),
                defense: Array(3).fill(null).map(() => ([
                    {role: 'Left Defense', roleId: 'LD', player: null},
                    {role: 'Right Defense', roleId: 'RD', player: null}
                ])),
                goalie: {role: 'Goalie', roleId: 'G', player: null}
            };
            availableRoster = [...masterRoster];

            // Add new option to selector and select it
            const newGameData = {
                id: newGameId,
                name: newGameName,
                masterRoster: masterRoster,
                lineup: currentLineup,
                availableRoster: availableRoster
            };
            allGames.push(newGameData);

            renderGameSelector();
            gameSelectorEl.value = newGameId;
            selectGame(newGameId); // This will re-render

            // Only show modal if triggered manually, not on initial load
            if (masterRoster.length > 0) {
                 showModal("Game Created", `A new game template titled "${newGameName}" has been created locally. Remember to Save Lineup!`);
            }
        };

        /**
         * Loads the selected game template's data into the current state.
         * @param {string} id The game ID to select.
         */
        const selectGame = (id) => {
            const selectedGame = allGames.find(g => g.id === id);
            if (!selectedGame) {
                console.warn(`Game ID ${id} not found.`);
                return;
            }

            currentGameId = id;
            masterRoster = selectedGame.masterRoster || [];
            availableRoster = selectedGame.availableRoster || [...masterRoster];
            currentLineup = selectedGame.lineup;

            // Update CSV input for reference (Name, Number, Shot)
            csvInputEl.value = masterRoster.map(p => `${p.name},${p.number || ''},${p.shot || ''}`).join('\n');

            renderAll();
        };

        // Event listener for game selection change
        gameSelectorEl.addEventListener('change', (e) => {
            selectGame(e.target.value);
        });

        // --- ROSTER DATA HANDLING ---

        /**
         * Parses CSV text into a structured list of players.
         * @param {string} csvText - The raw CSV string.
         * @returns {Array<object>} The parsed list of player objects.
         */
        const parseRosterCSV = (csvText) => {
            const players = [];
            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            const validShots = ['LH', 'RH'];

            for (const line of lines) {
                const parts = line.split(',').map(p => p.trim());
                // Expect Name, Number, Shot (3 fields)
                if (parts.length < 3) continue;

                const name = parts[0];
                const number = parts[1] ? parts[1].trim() : 'N/A'; // Number is index 1
                const shot = parts[2].toUpperCase(); // Shot is index 2

                if (name && validShots.includes(shot)) {
                    players.push({
                        id: generateUUID(),
                        name: name,
                        number: number,
                        shot: shot,
                    });
                }
            }
            return players;
        }

        /**
         * Parses the CSV input from the textarea and updates the state.
         * @param {string} [data] - Optional CSV string (used for default loading).
         * @param {boolean} [isDefaultLoad=false] - Whether this is the initial default load.
         */
        window.loadRosterFromCSV = (data, isDefaultLoad = false) => {
            const csvText = data || csvInputEl.value.trim();

            if (!csvText) {
                if (!isDefaultLoad) showModal("Roster Error", "Please enter player data in the CSV input area.");
                return;
            }

            const players = parseRosterCSV(csvText);

            if (players.length === 0) {
                if (!isDefaultLoad) showModal("Roster Error", "No valid players found. Ensure format is 'Name, Number, Shot (LH/RH)'.");
                return;
            }

            masterRoster = players;

            // Reset lineup and available roster for the new master list
            currentLineup = {
                forwards: Array(4).fill(null).map(() => ([
                    {role: 'Left Forward', roleId: 'LF', player: null},
                    {role: 'Center Forward', roleId: 'CF', player: null},
                    {role: 'Right Forward', roleId: 'RF', player: null}
                ])),
                defense: Array(3).fill(null).map(() => ([
                    {role: 'Left Defense', roleId: 'LD', player: null},
                    {role: 'Right Defense', roleId: 'RD', player: null}
                ])),
                goalie: {role: 'Goalie', roleId: 'G', player: null}
            };
            availableRoster = [...masterRoster];

            renderAll();
            if (!isDefaultLoad) {
                showModal("Roster Loaded", `${masterRoster.length} players loaded into the available roster.`);
            }
        };


        // --- RENDERING FUNCTIONS ---

        /**
         * Renders the list of saved games in the dropdown.
         */
        const renderGameSelector = () => {
            gameSelectorEl.innerHTML = '';
            if (allGames.length === 0) {
                const opt = document.createElement('option');
                opt.textContent = "No saved games (Starting New)";
                opt.disabled = true;
                gameSelectorEl.appendChild(opt);
                return;
            }

            allGames.forEach(game => {
                const opt = document.createElement('option');
                opt.value = game.id;
                opt.textContent = game.name;
                gameSelectorEl.appendChild(opt);
            });

            if (currentGameId) {
                gameSelectorEl.value = currentGameId;
            }
        };

        /**
         * Creates a draggable player card element.
         * @param {object} player - Player object.
         * @returns {HTMLElement}
         */
        const createPlayerCard = (player) => {
            // Simple heuristic for goalie: check name/number for typical goalie characteristics
            const isGoalie = player.number === '1'; // A common low goalie number
            const colorClass = isGoalie ? 'is-goalie-type' : (player.shot === 'LH' ? 'is-lh' : 'is-rh');

            const card = document.createElement('div');
            card.className = `player-card p-2 rounded-lg shadow-sm border text-sm font-medium transition duration-150 flex justify-between items-center ${colorClass}`;
            card.draggable = true;
            
            // Set inner content to include name, number prominently, and shot
            card.innerHTML = `
                <span class="flex-grow text-gray-900 truncate">${player.name}</span>
                <div class="flex items-center space-x-3">
                    <!-- Shot Badge (Smaller) -->
                    <span class="px-2 py-0.5 text-xs font-bold rounded-full bg-white bg-opacity-80 shadow-inner">${player.shot}</span>
                    <!-- Number (Prominent) -->
                    <span class="text-xl font-extrabold text-gray-800">${player.number}</span>
                </div>
            `;
            
            // Store player ID and source info in data-attributes
            card.setAttribute('data-player-id', player.id);
            card.setAttribute('data-source', 'roster'); // Source: roster

            card.addEventListener('dragstart', handleDragStart);
            return card;
        };

        /**
         * Renders the available roster list.
         */
        const renderRoster = () => {
            rosterListEl.innerHTML = '';
            if (availableRoster.length === 0 && masterRoster.length > 0) {
                 rosterListEl.innerHTML = '<p class="text-center text-gray-500 italic p-4">All players are currently placed in the lineup!</p>';
            }
            availableRoster.forEach(player => {
                rosterListEl.appendChild(createPlayerCard(player));
            });
            rosterCountEl.textContent = availableRoster.length;
        };

        /**
         * Renders a single lineup slot element.
         * @param {string} role - The role description (e.g., 'Left Defense').
         * @param {string} roleId - The role ID (e.g., 'LD', 'CF').
         * @param {object|null} player - The player occupying the slot, or null.
         * @param {string} slotIdentifier - Unique string (e.g., 'F1-CF', 'D2-LD', 'G1-G').
         * @returns {HTMLElement}
         */
        const createLineupSlot = (role, roleId, player, slotIdentifier) => {
            const isGoalieSlot = roleId === 'G';
            const isDefenseSlot = roleId === 'LD' || roleId === 'RD';
            const isForwardSlot = !isGoalieSlot && !isDefenseSlot;

            const borderColor = isGoalieSlot ? 'border-red-400' : 
                                isDefenseSlot ? 'border-green-400' : 'border-blue-400';

            const slot = document.createElement('div');
            slot.className = `lineup-slot p-2 rounded-lg border-2 border-dashed flex flex-col justify-center items-center text-center relative ${borderColor} ${player ? 'border-solid !border-transparent bg-opacity-70 shadow-md' : 'bg-gray-50 hover:bg-gray-100'}`;

            slot.setAttribute('data-role-id', roleId);
            slot.setAttribute('data-slot-id', slotIdentifier);

            if (player) {
                // If occupied, render the player card but add necessary slot identifiers
                const card = createPlayerCard(player);
                card.classList.remove('player-card'); // Use player-card style but remove cursor/active effect
                card.draggable = true; // Still allow dragging out of the slot
                card.setAttribute('data-source', 'lineup'); // Source: lineup
                card.setAttribute('data-slot-id', slotIdentifier); // Identify the slot it came from
                
                // Card in slot needs to be a bit more subtle in color
                card.classList.add('bg-opacity-50');

                slot.innerHTML = `<span class="text-xs font-semibold uppercase text-gray-500">${role}</span>`;
                slot.appendChild(card);

                // Add a remove button
                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '&times;';
                removeBtn.className = 'absolute top-0 right-0 text-xl font-bold p-1 leading-none text-gray-700 hover:text-red-600 transition duration-150';
                removeBtn.onclick = (e) => {
                    e.stopPropagation(); // Prevent drag events from interfering
                    movePlayerToRoster(player.id);
                };
                slot.appendChild(removeBtn);

            } else {
                // If empty, display role
                slot.innerHTML = `<span class="text-xs font-semibold uppercase text-gray-500">${role}</span>
                                  <span class="text-sm text-gray-400 italic">Drag Player Here</span>`;
            }

            slot.addEventListener('dragover', handleDragOver);
            slot.addEventListener('dragleave', handleDragLeave);
            slot.addEventListener('drop', handleDrop);
            return slot;
        };

        /**
         * Renders all lines (Forwards, Defense, Goalie).
         */
        const renderLineup = () => {
            forwardLinesEl.innerHTML = '';
            currentLineup.forwards.forEach((line, lineIndex) => {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'grid grid-cols-3 gap-3 p-3 bg-blue-50 rounded-lg shadow-inner border border-blue-200';
                line.forEach((slot, slotIndex) => {
                    const slotId = `F${lineIndex + 1}-${slot.roleId}`;
                    lineDiv.appendChild(createLineupSlot(slot.role, slot.roleId, slot.player, slotId));
                });
                forwardLinesEl.appendChild(lineDiv);
            });

            defenseLinesEl.innerHTML = '';
            currentLineup.defense.forEach((line, lineIndex) => {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'grid grid-cols-2 gap-3 p-3 bg-green-50 rounded-lg shadow-inner border border-green-200';
                line.forEach((slot, slotIndex) => {
                    const slotId = `D${lineIndex + 1}-${slot.roleId}`;
                    lineDiv.appendChild(createLineupSlot(slot.role, slot.roleId, slot.player, slotId));
                });
                defenseLinesEl.appendChild(lineDiv);
            });

            goalieLineEl.innerHTML = '';
            const gSlot = currentLineup.goalie;
            const gSlotId = `G1-${gSlot.roleId}`;
            // Added bg-red-50 and border-red-200 to the Goalie line wrapper for overall red tint
            const goalieWrapper = document.createElement('div');
            goalieWrapper.className = 'grid grid-cols-1 gap-3 p-3 bg-red-50 rounded-lg shadow-inner border border-red-200';
            goalieWrapper.appendChild(createLineupSlot(gSlot.role, gSlot.roleId, gSlot.player, gSlotId));
            goalieLineEl.appendChild(goalieWrapper);
        };

        /**
         * Re-renders the entire UI.
         */
        const renderAll = () => {
            renderRoster();
            renderLineup();
        };


        // --- DRAG AND DROP LOGIC ---

        /**
         * Start of drag operation. Stores data about the dragged player.
         */
        const handleDragStart = (e) => {
            const playerId = e.target.getAttribute('data-player-id');
            const source = e.target.getAttribute('data-source');
            const slotId = e.target.getAttribute('data-slot-id');

            e.dataTransfer.setData('text/plain', JSON.stringify({ playerId, source, slotId }));
            e.dataTransfer.effectAllowed = 'move';
            e.target.classList.add('opacity-50');
            
            e.target.addEventListener('dragend', handleDragEnd, { once: true });
        };
        
        /**
         * Resets opacity after drag operation completes (or is canceled).
         */
        const handleDragEnd = (e) => {
            e.target.classList.remove('opacity-50');
        };

        /**
         * Allows dropping by preventing default dragover behavior.
         */
        const handleDragOver = (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.currentTarget.classList.add('drag-over');
        };

        /**
         * Removes drag-over visual indicator.
         */
        const handleDragLeave = (e) => {
            e.currentTarget.classList.remove('drag-over');
        };

        /**
         * Handles the drop event into a lineup slot.
         */
        const handleDrop = (e) => {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const slotEl = e.currentTarget;
            const targetSlotId = slotEl.getAttribute('data-slot-id');

            try {
                const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
                const { playerId, source, slotId: sourceSlotId } = dragData;
                const playerToMove = masterRoster.find(p => p.id === playerId);

                if (!playerToMove) {
                    console.error("Dragged player not found in master roster.");
                    return;
                }

                // 1. Remove from source (roster or lineup)
                if (source === 'lineup') {
                    removePlayerFromLineupSlot(sourceSlotId);
                } else if (source === 'roster') {
                    availableRoster = availableRoster.filter(p => p.id !== playerId);
                }

                // 2. Handle existing player in the target slot (if any)
                const existingPlayerInSlot = getPlayerInSlot(targetSlotId);
                if (existingPlayerInSlot) {
                    // If the slot is occupied, move the existing player back to the available roster
                    if (existingPlayerInSlot.id !== playerId) {
                        availableRoster.push(existingPlayerInSlot);
                    }
                }

                // 3. Place new player in the target slot
                placePlayerInLineupSlot(targetSlotId, playerToMove);

                // Shot matching warning has been removed as requested.

                renderAll();
            } catch (error) {
                console.error("Error processing drop:", error);
            }
        };

        /**
         * Helper to find the player currently in a slot.
         * @param {string} slotId - e.g., 'F1-CF', 'D2-LD'.
         * @returns {object|null} The player object or null.
         */
        const getPlayerInSlot = (slotId) => {
            const match = slotId.match(/([A-Z])(\d+)-([A-Z]+)/);
            if (!match) return null;
            const [fullMatch, type, lineNum, roleId] = match;
            const lineIndex = parseInt(lineNum) - 1;

            if (type === 'F') {
                const roleIndex = currentLineup.forwards[lineIndex].findIndex(s => s.roleId === roleId);
                return currentLineup.forwards[lineIndex][roleIndex]?.player || null;
            } else if (type === 'D') {
                const roleIndex = currentLineup.defense[lineIndex].findIndex(s => s.roleId === roleId);
                return currentLineup.defense[lineIndex][roleIndex]?.player || null;
            } else if (type === 'G') {
                return currentLineup.goalie.player;
            }
            return null;
        };

        /**
         * Moves a player from the lineup back to the available roster.
         * @param {string} playerId - The ID of the player to move.
         */
        window.movePlayerToRoster = (playerId) => {
             // Find the slot the player is in and clear it
            let player = null;

            // Check Forwards
            currentLineup.forwards.forEach((line, lIdx) => {
                line.forEach((slot, pIdx) => {
                    if (slot.player && slot.player.id === playerId) {
                        player = slot.player;
                        currentLineup.forwards[lIdx][pIdx].player = null;
                    }
                });
            });

            // Check Defense
            currentLineup.defense.forEach((line, lIdx) => {
                line.forEach((slot, pIdx) => {
                    if (slot.player && slot.player.id === playerId) {
                        player = slot.player;
                        currentLineup.defense[lIdx][pIdx].player = null;
                    }
                });
            });

            // Check Goalie
            if (currentLineup.goalie.player && currentLineup.goalie.player.id === playerId) {
                player = currentLineup.goalie.player;
                currentLineup.goalie.player = null;
            }

            if (player) {
                if (!availableRoster.some(p => p.id === playerId)) {
                    availableRoster.push(player);
                }
                renderAll();
            }
        }

        /**
         * Clears a lineup slot of any player.
         * @param {string} slotId - The ID of the slot to clear.
         */
        const removePlayerFromLineupSlot = (slotId) => {
            const match = slotId.match(/([A-Z])(\d+)-([A-Z]+)/);
            if (!match) return;
            const [fullMatch, type, lineNum, roleId] = match;
            const lineIndex = parseInt(lineNum) - 1;

            if (type === 'F') {
                const roleIndex = currentLineup.forwards[lineIndex].findIndex(s => s.roleId === roleId);
                if (roleIndex !== -1) {
                    currentLineup.forwards[lineIndex][roleIndex].player = null;
                }
            } else if (type === 'D') {
                const roleIndex = currentLineup.defense[lineIndex].findIndex(s => s.roleId === roleId);
                if (roleIndex !== -1) {
                    currentLineup.defense[lineIndex][roleIndex].player = null;
                }
            } else if (type === 'G') {
                currentLineup.goalie.player = null;
            }
        };

        /**
         * Places a player into a lineup slot.
         * @param {string} slotId - The ID of the target slot.
         * @param {object} player - The player object to place.
         */
        const placePlayerInLineupSlot = (slotId, player) => {
            const match = slotId.match(/([A-Z])(\d+)-([A-Z]+)/);
            if (!match) return;
            const [fullMatch, type, lineNum, roleId] = match;
            const lineIndex = parseInt(lineNum) - 1;

            if (type === 'F') {
                const roleIndex = currentLineup.forwards[lineIndex].findIndex(s => s.roleId === roleId);
                 if (roleIndex !== -1) {
                    currentLineup.forwards[lineIndex][roleIndex].player = player;
                }
            } else if (type === 'D') {
                const roleIndex = currentLineup.defense[lineIndex].findIndex(s => s.roleId === roleId);
                if (roleIndex !== -1) {
                    currentLineup.defense[lineIndex][roleIndex].player = player;
                }
            } else if (type === 'G') {
                currentLineup.goalie.player = player;
            }
        };

        // --- APPLICATION START ---

        // Set the default roster into the textarea on load
        csvInputEl.value = DEFAULT_ROSTER_CSV.trim();

        // Initialize on window load
        window.addEventListener('load', initializeFirebase);

    </script>
</body>
</html>
