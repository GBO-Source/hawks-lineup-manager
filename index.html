<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>Hawks 503 Lineup Manager (Firestore)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fc; }
        /* Custom styles for drag-and-drop */
        .player-card {
            cursor: grab;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .player-card:active {
            cursor: grabbing;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 4, 18, 0.05);
            transform: scale(1.02);
        }
        .lineup-slot {
            min-height: 4rem; /* Ensure drop target is large enough */
            transition: background-color 0.15s, border-color 0.15s;
        }
        .drag-over {
            background-color: #e0f2fe !important; /* light-blue-100 */
            border-color: #3b82f6 !important; /* blue-500 */
        }
        
        /* Color Coding based on Shot */
        .is-lh {
            /* ORANGE tint for LH (Left Handed) shots */
            background-color: #fff7ed; /* Orange-100 */
            color: #c2410c; /* Orange-700 */
            border-color: #fb923c; /* Orange-400 */
        }
        .is-rh {
            /* YELLOW tint for RH (Right Handed) shots */
            background-color: #fefce8; /* Yellow-100 */
            color: #a16207; /* Yellow-700 */
            border-color: #facc15; /* Yellow-400 */
        }
        /* Goalie card is now styled with RED colors */
        .is-goalie-type {
            background-color: #fef2f2; /* Red-50 */
            color: #b91c1c; /* Red-700 */
            border-color: #f87171; /* Red-400 */
        }
    </style>
</head>
<body class="p-4 md:p-8">
<header class="mb-8">
    <h1 class="text-4xl font-extrabold text-gray-900 mb-2">Hawks 503 Lineup Manager üèí (Firestore)</h1>
    <p class="text-lg text-gray-600">Build your lines using Name, Number, and Shot (LH/RH). Data is saved persistently.</p>
</header>
<section class="bg-white p-6 rounded-xl shadow-lg mb-8">
    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Game &amp; Roster Setup</h2>
    <div class="text-sm text-gray-500 mb-4 flex flex-col md:flex-row md:justify-between md:items-center" id="auth-info">
        <span class="font-medium text-red-500" id="storage-info">Initializing Firestore...</span>
        <span id="app-id-display" class="mt-1 md:mt-0">App Mode: Loading...</span>
    </div>
    <div class="mb-4 flex flex-col md:flex-row md:items-center space-y-2 md:space-y-0 md:space-x-4">
        <label class="font-medium text-gray-700 whitespace-nowrap" for="game-selector">Load/New Lineup:</label>
        <select class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" id="game-selector" onchange="loadSelectedLineup()">
            <option value="" disabled selected>Select or create a lineup...</option>
        </select>
        <button class="bg-green-600 text-white p-2 rounded-lg hover:bg-green-700 transition duration-150 shadow-md whitespace-nowrap" onclick="createNewGame()">
            <svg class="h-5 w-5 inline mr-1" fill="currentColor" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path clip-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" fill-rule="evenodd"></path>
            </svg>
            New Lineup
        </button>
        <button class="bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition duration-150 shadow-md" onclick="saveLineup()">
            <svg class="h-5 w-5 inline mr-1" fill="currentColor" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path d="M7 3a1 1 0 000 2h6a1 1 0 100-2H7z"></path>
                <path clip-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" fill-rule="evenodd"></path>
            </svg>
            Save Lineup
        </button>
    </div>
    <div class="mt-6">
        <label class="block font-medium text-gray-700 mb-1" for="csv-input">Roster Data (Enter CSV and click "Load Roster" to update the current lineup):</label>
        <textarea class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-sm" id="csv-input" placeholder="Example:
Name,Number,Shot
Connor McDavid,97,RH
Leon Draisaitl,29,LH
Morgan Rielly,44,LH
Carey Price,31,G
..." rows="8"></textarea>
        <button class="mt-2 bg-indigo-600 text-white p-2 rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md w-full" onclick="loadRosterData()">Load Roster (from text)</button>
    </div>
</section>
<div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
    <section class="lg:col-span-1 bg-white p-6 rounded-xl shadow-lg">
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">Available Roster (<span id="roster-count">0</span>)</h2>
        <div class="space-y-2 max-h-[60vh] overflow-y-auto" id="roster-list">
        </div>
    </section>
    <section class="lg:col-span-3 bg-white p-6 rounded-xl shadow-lg">
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">Current Lineup: <span id="current-lineup-name" class="font-bold text-gray-600">None Selected</span></h2>
        <h3 class="text-xl font-medium text-blue-800 mb-2 mt-4 flex items-center">
            <svg class="h-6 w-6 mr-2" fill="currentColor" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path clip-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" fill-rule="evenodd"></path>
            </svg>
            Forward Lines (4)
        </h3>
        <div class="space-y-4" id="forward-lines">
        </div>
        <h3 class="text-xl font-medium text-green-800 mb-2 mt-6 flex items-center">
            <svg class="h-6 w-6 mr-2" fill="currentColor" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path clip-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" fill-rule="evenodd"></path>
            </svg>
            Defense Pairings (3)
        </h3>
        <div class="space-y-4" id="defense-lines">
        </div>
        <h3 class="text-xl font-medium text-red-800 mb-2 mt-6 flex items-center">
            <svg class="h-6 w-6 mr-2" fill="currentColor" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path clip-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 100 2h6a1 1 0 100-2H7z" fill-rule="evenodd"></path>
            </svg>
            Goalie (1)
        </h3>
        <div class="grid grid-cols-1 gap-4" id="goalie-line">
        </div>
    </section>
</div>
<div class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center p-4 z-50" id="message-modal">
    <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm">
        <h3 class="text-xl font-bold mb-3 text-gray-800" id="modal-title"></h3>
        <p class="mb-4 text-gray-600" id="modal-message"></p>
        <button class="w-full bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition duration-150" onclick="closeModal()">Close</button>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, collection, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Global State ---
    let currentRoster = []; // The complete list of available players
    let currentLineupId = ''; // The unique ID of the currently loaded/new lineup
    let db, auth, userId;
    let isAuthReady = false; // NEW: Flag to ensure Firestore operations wait for authentication
    const lineupStructure = {}; // Holds the structure of the slots
    const lineupContainerIds = ['forward-lines', 'defense-lines', 'goalie-line'];

    // Safely retrieve and parse global variables from Canvas environment
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    let firebaseConfig = {};
    try {
        firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
    } catch (e) {
        console.error("Failed to parse __firebase_config:", e);
        // Fallback or explicit error handled below
    }

    // --- Firebase & Auth Setup ---

    /**
     * Initializes Firebase and handles authentication.
     */
    async function initializeFirebase() {
        if (Object.keys(firebaseConfig).length === 0) {
            document.getElementById('storage-info').textContent = "ERROR: Firebase config is missing or invalid.";
            console.error("FATAL ERROR: Firebase configuration is empty.");
            return;
        }

        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            setLogLevel('Debug'); // Enable Firebase logging

            document.getElementById('app-id-display').textContent = `App ID: ${appId}`;

            // Authenticate user
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
            
            // Set up listener for auth state changes
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    isAuthReady = true; // Set flag when user is identified
                    document.getElementById('storage-info').innerHTML = 
                        `<span class="font-bold text-green-700">Data saved to Firestore</span> | User ID: ${userId.substring(0, 8)}...`;
                    loadLineupList();
                } else {
                    isAuthReady = false;
                    document.getElementById('storage-info').textContent = "Not authenticated.";
                }
            });

        } catch (error) {
            console.error("Firebase Init/Auth Error:", error);
            showModal("Connection Error", "Failed to connect to Firebase services. See console for details.");
        }
    }
    
    // --- Data Path Helpers ---

    /**
     * Gets the collection reference for the public lineups.
     */
    function getLineupsCollectionRef() {
        if (!isAuthReady || !db) {
            console.error("Attempted to get collection ref before auth was ready.");
            return null;
        }
        // Public data path: /artifacts/{appId}/public/data/lineups
        return collection(db, 'artifacts', appId, 'public', 'data', 'lineups');
    }

    /**
     * Gets the document reference for a specific lineup ID.
     */
    function getLineupDocRef(lineupId) {
        if (!isAuthReady || !db) {
            console.error("Attempted to get document ref before auth was ready.");
            return null;
        }
        return doc(db, 'artifacts', appId, 'public', 'data', 'lineups', lineupId);
    }

    // --- Lineup Management (Saving/Loading) ---
    
    /**
     * Gathers the current lineup state from the DOM.
     * @returns {Object} A map of slot labels to player IDs.
     */
    function getCurrentLineupState() {
        const lineupState = {};
        document.querySelectorAll('.lineup-slot').forEach(slot => {
            const slotLabel = slot.getAttribute('data-slot-label');
            // Look for the player-card element directly inside the slot
            const playerCard = slot.querySelector('.player-card'); 
            
            if (playerCard) {
                lineupState[slotLabel] = playerCard.getAttribute('data-player-id');
            } else {
                lineupState[slotLabel] = null; // Slot is empty
            }
        });
        return lineupState;
    }

    /**
     * Saves the current roster and lineup state to Firestore.
     */
    window.saveLineup = async function() {
        if (!isAuthReady) {
             showModal("Wait", "Please wait for Firebase initialization to complete.");
             return;
        }
        if (!currentLineupId || !currentRoster || currentRoster.length === 0) {
            showModal("Save Error", "Please create a lineup, load a roster, and assign players before saving.");
            return;
        }

        const lineupData = {
            id: currentLineupId,
            name: document.getElementById('current-lineup-name').textContent,
            roster: currentRoster, 
            lineup: getCurrentLineupState(), 
            lastUpdated: new Date().toISOString()
        };

        try {
            const docRef = getLineupDocRef(currentLineupId);
            if (docRef) {
                await setDoc(docRef, lineupData);
                loadLineupList(); 
                showModal("Success", `Lineup "${lineupData.name}" saved to Firestore.`);
            }
        } catch (error) {
            console.error("Firestore Save Error:", error);
            showModal("Error Saving", "Failed to save lineup data. Check console for details.");
        }
    }

    /**
     * Loads the list of available lineups from Firestore into the selector.
     */
    async function loadLineupList() {
        if (!isAuthReady) return; // Prevent calls before auth is ready

        const selector = document.getElementById('game-selector');
        selector.innerHTML = '<option value="" disabled selected>Select or create a lineup...</option>';
        const colRef = getLineupsCollectionRef();
        if (!colRef) return;

        try {
            const querySnapshot = await getDocs(colRef);
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                const option = document.createElement('option');
                // NEW: Ensure all necessary fields exist
                if (data.id && data.name) { 
                    option.value = data.id;
                    option.textContent = data.name;
                    selector.appendChild(option);
                }
            });
            
            // Re-select the currently loaded lineup if it exists
            if (currentLineupId) {
                selector.value = currentLineupId;
            }
        } catch (error) {
            console.error("Firestore Load List Error:", error);
        }
    }
    
    /**
     * Loads the lineup selected in the dropdown.
     */
    window.loadSelectedLineup = async function() {
        if (!isAuthReady) {
             showModal("Wait", "Please wait for Firebase initialization to complete.");
             return;
        }

        const selector = document.getElementById('game-selector');
        const lineupId = selector.value;

        if (!lineupId) return;

        try {
            const docRef = getLineupDocRef(lineupId);
            if (!docRef) return;

            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const data = docSnap.data();
                
                // NEW: Use safe defaults for data integrity
                currentRoster = data.roster || [];
                const lineupState = data.lineup || {};
                
                if (currentRoster.length === 0) {
                     showModal("Roster Warning", "The loaded lineup has no roster data. Please load a roster via CSV.");
                }

                // 1. Update state
                currentLineupId = data.id;
                
                // 2. Render Roster (This populates the left panel)
                renderRoster();

                // 3. Render Lineup (This populates the slots)
                clearLineupSlots(); 
                renderLineup(lineupState);
                
                document.getElementById('current-lineup-name').textContent = data.name || "Untitled Lineup";
                
                showModal("Lineup Loaded", `Lineup "${data.name}" loaded successfully.`);

            } else {
                showModal("Load Error", "Lineup not found in database.");
            }
        } catch (error) {
            console.error("Firestore Load Error:", error);
            showModal("Error Loading", "Failed to load lineup data. Check console for details.");
        }
    }

    /**
     * Prompts the user for a new lineup name and resets the UI.
     */
    window.createNewGame = function() {
        if (!isAuthReady) {
             showModal("Wait", "Please wait for Firebase initialization to complete.");
             return;
        }

        const lineupName = prompt("Enter a name for the new lineup:");
        if (lineupName && lineupName.trim() !== '') {
            currentLineupId = crypto.randomUUID(); 
            document.getElementById('current-lineup-name').textContent = lineupName.trim();
            
            // Use the roster currently in the CSV box as a starting point if available
            const csvInput = document.getElementById('csv-input');
            currentRoster = parseCSV(csvInput.value); // Re-parse for new game

            renderRoster();
            clearLineupSlots();
            
            // Update selector to reflect the new, unsaved game
            const selector = document.getElementById('game-selector');
            selector.value = ''; // Deselect any option
            
            showModal("New Lineup Created", `Start assembling your new lineup: "${lineupName.trim()}". Click 'Save Lineup' when finished.`);
        } else if (lineupName !== null) {
            showModal("Invalid Name", "Lineup name cannot be empty.");
        }
    }
    
    // --- Roster Data Logic (CSV Parsing) ---

    /**
     * Parses the CSV input from the textarea and converts it into an array of player objects.
     */
    function parseCSV(csvString) {
        if (!csvString) return [];
        const lines = csvString.trim().split('\n');
        if (lines.length < 2) {
             // Don't show modal here as it can be called internally on a new game
             return [];
        }

        const headers = lines[0].split(',').map(h => h.trim());
        const dataLines = lines.slice(1);
        if (headers.length < 3 || headers[0].toLowerCase() !== 'name' || headers[1].toLowerCase() !== 'number' || headers[2].toLowerCase() !== 'shot') {
             showModal("Roster Load Error", "CSV header format incorrect. Expected: Name,Number,Shot");
             return [];
        }

        const roster = dataLines.map((line) => {
            const values = line.split(',').map(v => v.trim());
            if (values.length < 3 || values[0] === "") return null; 

            const shot = values[2].toUpperCase();
            
            // Use a stable ID if possible, otherwise generate a new one (prevents ID collision when re-parsing)
            const stableId = values.join('|').replace(/[^a-zA-Z0-9|]/g, ''); 
            
            return {
                // Generate a consistent ID based on player data for predictable roster loading
                id: 'player-' + stableId, 
                name: values[0] || 'Unknown Player',
                number: values[1] ? parseInt(values[1]) : 0,
                shot: shot, 
            };
        }).filter(player => player !== null && player.name && (player.shot === 'LH' || player.shot === 'RH' || player.shot === 'G'));
        
        return roster;
    }

    /**
     * Main function called by the "Load Roster" button (updates the roster for the CURRENT lineup).
     */
    window.loadRosterData = function() {
        if (!currentLineupId) {
            showModal("Load Error", "Please create a new lineup or select an existing one first.");
            return;
        }

        const csvInput = document.getElementById('csv-input');
        const csvString = csvInput.value;

        if (csvString.trim() === '') {
            showModal("No Data", "Please enter player data into the text box first.");
            return;
        }

        currentRoster = parseCSV(csvString);
        renderRoster();
        // After loading a new roster, clear the lineup slots to reflect the new set of players,
        // preventing display of players who might have been removed from the roster.
        clearLineupSlots(); 
        showModal("Roster Updated", "Roster loaded successfully. Drag players to their slots.");
    }
    
    // --- UI Rendering ---

    /**
     * Creates the HTML element for a player card.
     */
    function createPlayerCard(player) {
        const card = document.createElement('div');
        let shotClass = 'border-gray-300';
        
        if (player.shot === 'LH') {
            shotClass = 'is-lh';
        } else if (player.shot === 'RH') {
            shotClass = 'is-rh';
        } else if (player.shot === 'G') {
            shotClass = 'is-goalie-type'; 
        }

        card.className = `player-card p-2 rounded-lg border shadow-sm flex justify-between items-center text-sm font-medium ${shotClass}`;
        card.setAttribute('draggable', true); // ALL cards created here are draggable
        card.setAttribute('data-player-id', player.id);
        card.setAttribute('data-player-shot', player.shot);

        card.innerHTML = `
            <span>${player.name} <span class="text-gray-500 font-normal">#${player.number}</span></span>
            <span class="px-2 py-0.5 rounded-full text-xs font-semibold">${player.shot}</span>
        `;
        
        card.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', player.id);
            // Add a class to hide the original card temporarily during drag
            setTimeout(() => card.classList.add('opacity-40'), 0);
        });
        card.addEventListener('dragend', () => {
            card.classList.remove('opacity-40');
        });
        
        return card;
    }

    /**
     * Renders the currentRoster array into the 'Available Roster' list.
     */
    function renderRoster() {
        const rosterList = document.getElementById('roster-list');
        const rosterCount = document.getElementById('roster-count');
        rosterList.innerHTML = ''; 

        // Get IDs of players currently in the lineup slots
        const lineupPlayerIds = new Set(Object.values(getCurrentLineupState()).filter(id => id !== null));

        currentRoster.forEach(player => {
            // Only add players to the available list if they are NOT in a lineup slot
            if (!lineupPlayerIds.has(player.id)) {
                rosterList.appendChild(createPlayerCard(player)); // Always draggable
            }
        });

        rosterCount.textContent = currentRoster.length - lineupPlayerIds.size;
    }
    
    /**
     * Clears all player cards from the lineup slots and resets them to labels.
     */
    function clearLineupSlots() {
        document.querySelectorAll('.lineup-slot').forEach(slot => {
            slot.innerHTML = slot.getAttribute('data-slot-label');
        });
    }

    /**
     * Renders the saved lineup state into the slots.
     */
    function renderLineup(lineupState) {
        // Iterate over the saved lineup state
        for (const [slotLabel, playerId] of Object.entries(lineupState)) {
            if (playerId) {
                const player = currentRoster.find(p => p.id === playerId);
                const slot = document.querySelector(`[data-slot-label="${slotLabel}"]`);

                if (player && slot) {
                    const lineupCard = createPlayerCard(player); // The card in the slot is also draggable
                    slot.innerHTML = '';
                    slot.appendChild(lineupCard);
                } else if (!player && slot) {
                    // Player ID existed in the lineup but is missing from the roster, clear the slot
                    slot.innerHTML = slot.getAttribute('data-slot-label');
                }
            }
        }
        renderRoster(); // Update the available roster list after filling the slots
    }
    
    /**
     * Dynamically sets up the empty lineup slots and drag/drop listeners.
     */
    function setupLineupSlots() {
        const structure = {
            'forward-lines': { cols: 3, lines: 4, labels: ['LW', 'C', 'RW'] },
            'defense-lines': { cols: 2, lines: 3, labels: ['LD', 'RD'] },
            'goalie-line': { cols: 1, lines: 1, labels: ['G'] }
        };

        for (const [containerId, details] of Object.entries(structure)) {
            const container = document.getElementById(containerId);
            for (let line = 1; line <= details.lines; line++) {
                const lineDiv = document.createElement('div');
                lineDiv.className = `grid grid-cols-${details.cols} gap-4 border-b border-gray-200 py-2`;
                
                details.labels.forEach((label) => {
                    const slotLabel = containerId === 'goalie-line' ? label : (line + "-" + label);
                    
                    const slot = document.createElement('div');
                    slot.className = 'lineup-slot p-3 border-2 border-dashed border-gray-300 rounded-lg text-center text-gray-500 font-normal';
                    slot.setAttribute('data-slot-label', slotLabel);
                    slot.textContent = slotLabel;
                    lineDiv.appendChild(slot);
                    
                    lineupStructure[slotLabel] = slot;
                    
                    // Add drag/drop listeners
                    slot.addEventListener('dragover', (e) => {
                        e.preventDefault(); 
                        slot.classList.add('drag-over');
                    });

                    slot.addEventListener('dragleave', () => {
                        slot.classList.remove('drag-over');
                    });

                    slot.addEventListener('drop', (e) => {
                        e.preventDefault();
                        slot.classList.remove('drag-over');
                        
                        const playerId = e.dataTransfer.getData('text/plain');
                        const draggedElement = document.querySelector(`[data-player-id="${playerId}"]`);
                        
                        if (!draggedElement) return;

                        // Check if the source element was from inside a slot (i.e., moving a player)
                        const sourceSlot = draggedElement.closest('.lineup-slot');

                        // Check if the drop target is already occupied
                        if (slot.querySelector('.player-card')) {
                            // If source and target are different slots, swap them
                            if (sourceSlot && sourceSlot !== slot) {
                                const targetCard = slot.querySelector('.player-card');
                                
                                // Swap logic: move card from slot to sourceSlot, and dragged element to slot
                                slot.innerHTML = '';
                                sourceSlot.innerHTML = '';
                                
                                sourceSlot.appendChild(targetCard);
                                slot.appendChild(draggedElement);

                                // The dragged element might be outside the roster, so we need to fix its opacity manually
                                draggedElement.classList.remove('opacity-40');
                                
                                // Swap complete, no need to touch roster
                                return;
                            } else {
                                // Dropping onto the same occupied slot (or just dropping a new player onto an occupied slot)
                                showModal("Slot Full", "This lineup slot is already occupied. Drag the existing player out first, or swap players.");
                                draggedElement.classList.remove('opacity-40');
                                return;
                            }
                        } 
                        
                        // Drop onto an empty slot
                        if (sourceSlot) {
                            // Moving from one slot to an empty slot, just clear the source slot
                            sourceSlot.innerHTML = sourceSlot.getAttribute('data-slot-label');
                        } else {
                            // Moving from roster to slot (The draggedElement is still a clone from roster-list)
                            // We need to find the original player object to create a fresh, permanent card in the slot
                            const player = currentRoster.find(p => p.id === playerId);
                            if (player) {
                                const lineupCard = createPlayerCard(player);
                                slot.innerHTML = '';
                                slot.appendChild(lineupCard);
                            }
                        }

                        // Always ensure the opacity is fixed and the roster/count is updated
                        draggedElement.classList.remove('opacity-40');
                        renderRoster(); // Updates the roster panel and count based on new state
                    });
                    
                    // Add a click listener to remove player from slot and return to roster
                    slot.addEventListener('click', (e) => {
                        const card = e.currentTarget.querySelector('.player-card');
                        if (card) {
                            e.currentTarget.innerHTML = e.currentTarget.getAttribute('data-slot-label');
                            renderRoster(); // Re-render to put the player back in the available list
                        }
                    });
                });
                container.appendChild(lineDiv);
            }
        }
    }

    // --- Modal/Message Functions ---
    const modal = document.getElementById('message-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalMessage = document.getElementById('modal-message');

    function showModal(title, message) {
        modalTitle.textContent = title;
        modalMessage.textContent = message;
        modal.classList.remove('hidden');
        modal.classList.add('flex');
    }

    window.closeModal = function() {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
    }
    
    // --- Initialization ---
    document.addEventListener("DOMContentLoaded", function() {
        setupLineupSlots();
        initializeFirebase();
    });

</script>
