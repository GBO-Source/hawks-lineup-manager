<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hawks 503 Lineup Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fc; }
        /* Custom styles for drag-and-drop */
        .player-card {
            cursor: grab;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .player-card:active {
            cursor: grabbing;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 4, 18, 0.05);
            transform: scale(1.02);
        }
        .lineup-slot {
            min-height: 4rem; /* Ensure drop target is large enough */
            transition: background-color 0.15s, border-color 0.15s;
        }
        .drag-over {
            background-color: #e0f2fe !important; /* light-blue-100 */
            border-color: #3b82f6 !important; /* blue-500 */
        }
        
        /* New Color Coding based on Shot */
        .is-lh {
            /* This is the ORANGE tint for LH (Left Handed) shots */
            background-color: #fff7ed; /* Orange-100 */
            color: #c2410c; /* Orange-700 */
            border-color: #fb923c; /* Orange-400 */
        }
        .is-rh {
            /* This is the YELLOW tint for RH (Right Handed) shots */
            background-color: #fefce8; /* Yellow-100 */
            color: #a16207; /* Yellow-700 */
            border-color: #facc15; /* Yellow-400 */
        }
        /* Goalie card is now styled with RED colors */
        .is-goalie-type {
            background-color: #fef2f2; /* Red-50 */
            color: #b91c1c; /* Red-700 */
            border-color: #f87171; /* Red-400 */
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <header class="mb-8">
        <h1 class="text-4xl font-extrabold text-gray-900 mb-2">Hawks 503 Lineup Manager üèí</h1>
        <p class="text-lg text-gray-600">Build your lines using Name, Number, and Shot (LH/RH).</p>
    </header>

    <section class="bg-white p-6 rounded-xl shadow-lg mb-8">
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">Game & Roster Setup</h2>

        <div id="auth-info" class="text-sm text-gray-500 mb-4 flex justify-between items-center">
            <span id="user-id-display" class="font-medium text-red-500">Initialization Failed. Loading Default.</span>
            <span id="app-id-display"></span>
        </div>

        <div class="mb-4 flex flex-col md:flex-row md:items-center space-y-2 md:space-y-0 md:space-x-4">
            <label for="game-selector" class="font-medium text-gray-700">Load/New Game:</label>
            <select id="game-selector" class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500"></select>
            <button onclick="createNewGame()" class="bg-green-600 text-white p-2 rounded-lg hover:bg-green-700 transition duration-150 shadow-md whitespace-nowrap">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                </svg>
                New Game
            </button>
            <button onclick="saveGame()" class="bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M7 3a1 1 0 000 2h6a1 1 0 100-2H7z" />
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
                Save Lineup
            </button>
        </div>

        <div class="mt-6">
            <label for="csv-input" class="block font-medium text-gray-700 mb-1">Roster Data (Edit and click "Load Roster" to update):</label>
            <textarea id="csv-input" rows="8" placeholder="Example:&#10;Name,Number,Shot&#10;Connor McDavid,97,RH&#10;Leon Draisaitl,29,LH&#10;..." class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-sm"></textarea>
            <button onclick="loadRosterData()" class="mt-2 bg-indigo-600 text-white p-2 rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md w-full">Load Roster</button>
        </div>
    </section>

    <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">

        <section class="lg:col-span-1 bg-white p-6 rounded-xl shadow-lg">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Available Roster (<span id="roster-count">0</span>)</h2>
            <div id="roster-list" class="space-y-2 max-h-[60vh] overflow-y-auto">
                </div>
        </section>

        <section class="lg:col-span-3 bg-white p-6 rounded-xl shadow-lg">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Current Lineup</h2>

            <h3 class="text-xl font-medium text-blue-800 mb-2 mt-4 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
                </svg>
                Forward Lines (4)
            </h3>
            <div id="forward-lines" class="space-y-4">
                </div>

            <h3 class="text-xl font-medium text-green-800 mb-2 mt-6 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
                Defense Pairings (3)
            </h3>
            <div id="defense-lines" class="space-y-4">
                </div>

            <h3 class="text-xl font-medium text-red-800 mb-2 mt-6 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
                </svg>
                Goalie (1)
            </h3>
            <div id="goalie-line" class="grid grid-cols-1 gap-4">
                </div>

        </section>
    </div>

    <div id="message-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h3 id="modal-title" class="text-xl font-bold mb-3 text-gray-800"></h3>
            <p id="modal-message" class="mb-4 text-gray-600"></p>
            <button onclick="closeModal()" class="w-full bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition duration-150">Close</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set Firebase logging level to Debug
        setLogLevel('Debug');

        // --- CONFIGURATION & Roster Data Source ---
        // The link provided by the user for the published Google Sheet CSV
        const GOOGLE_SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vS4nukvK7D-Q__ZKwqPbzflUAl0NOPjvad3PN-FAU_P79fnscTZmfaYhwgoIqf8AWCPTl6tVN6UYx2J/pub?gid=1943714911&single=true&output=csv';

        // Default roster data in CSV format used as a fallback
        const DEFAULT_ROSTER_CSV = `
Name,Number,Shot
Default Player 1,1,RH
Default Player 2,2,LH
Goalie Default,30,LH
`;
        
        // --- GLOBAL VARIABLES & DEFAULT DATA ---

        // State Management
        let app;
        let db;
        let auth;
        let userId = 'anon';
        let isAuthReady = false;

        let currentGameId = null;
        let allGames = []; // List of all saved games
        let masterRoster = []; // All players from CSV
        let availableRoster = []; // Players not currently in the lineup
        
        // Define lineup structure using role identifiers (not strict positions)
        let currentLineup = {
            forwards: Array(4).fill(null).map(() => ([
                {role: 'Left Forward', roleId: 'LF', player: null},
                {role: 'Center Forward', roleId: 'CF', player: null},
                {role: 'Right Forward', roleId: 'RF', player: null}
            ])),
            defense: Array(3).fill(null).map(() => ([
                {role: 'Left Defense', roleId: 'LD', player: null},
                {role: 'Right Defense', roleId: 'RD', player: null}
            ])),
            goalie: {role: 'Goalie', roleId: 'G', player: null}
        };

        // DOM elements
        const rosterListEl = document.getElementById('roster-list');
        const rosterCountEl = document.getElementById('roster-count');
        const forwardLinesEl = document.getElementById('forward-lines');
        const defenseLinesEl = document.getElementById('defense-lines');
        const goalieLineEl = document.getElementById('goalie-line');
        const gameSelectorEl = document.getElementById('game-selector');
        const csvInputEl = document.getElementById('csv-input');


        // --- UTILITY & MODAL FUNCTIONS ---

        /**
         * Generates a simple UUID for player tracking.
         */
        const generateUUID = () => crypto.randomUUID();

        /**
         * Displays a custom modal message.
         * @param {string} title
         * @param {string} message
         */
        window.showModal = (title, message) => {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').textContent = message;
            document.getElementById('message-modal').classList.remove('hidden');
            document.getElementById('message-modal').classList.add('flex');
        };

        /**
         * Closes the custom modal.
         */
        window.closeModal = () => {
            document.getElementById('message-modal').classList.add('hidden');
            document.getElementById('message-modal').classList.remove('flex');
        };

        // --- FIREBASE INITIALIZATION & AUTH (CORRECTED WITH DEBUGGING) ---

        /**
         * Initializes Firebase and sets up authentication listener.
         */
        const initializeFirebase = async () => {
            let firebaseConfig = null;
            let appId = 'default-app-id'; 
            let initialAuthToken = null;
            let failureReason = "Unknown initialization failure.";

            try {
                // DEBUG INFO: Check for and parse the Firebase config global variable
                if (typeof __firebase_config !== 'undefined' && __firebase_config) {
                    firebaseConfig = JSON.parse(__firebase_config);
                    appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    console.log("DEBUG INFO: __firebase_config found and parsed successfully.");
                } else {
                    failureReason = "The required '__firebase_config' is missing or empty in the environment.";
                    console.error("FIREBASE ERROR:", failureReason);
                    throw new Error("Missing Firebase configuration.");
                }

                // DEBUG INFO: Check for the initial auth token global variable
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    initialAuthToken = __initial_auth_token;
                    console.log("DEBUG INFO: __initial_auth_token found and will be used.");
                } else {
                    console.warn("DEBUG INFO: __initial_auth_token is missing. Falling back to anonymous sign-in.");
                }

                // 2. Initialize Firebase services
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                document.getElementById('app-id-display').textContent = `App ID: ${appId} (Public Data)`;

                // 3. Handle Authentication
                if (initialAuthToken) {
                    try {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("DEBUG INFO: Signed in successfully with custom token.");
                    } catch (error) {
                        failureReason = `Custom token sign-in failed. Error: ${error.message}`;
                        console.error("FIREBASE ERROR: Custom token failure. Attempting anonymous sign-in.", error);
                        await signInAnonymously(auth);
                    }
                } else {
                    await signInAnonymously(auth);
                }
                
                // 4. Auth State Change Listener (Sets userId and isAuthReady)
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('user-id-display').textContent = `User ID: ${userId.substring(0, 8)}...`;
                    } else {
                        // Fallback user ID if sign-in failed or user signed out
                        userId = crypto.randomUUID();
                        document.getElementById('user-id-display').textContent = `User ID: anon (${userId.substring(0, 4)}...)`;
                    }
                    isAuthReady = true;
                    document.getElementById('user-id-display').classList.remove('text-red-500');
                    document.getElementById('user-id-display').classList.add('text-gray-500');
                    console.log("DEBUG INFO: Auth state ready. User ID:", userId);
                    // Start listeners only after auth is confirmed ready
                    setupGameListener(appId);
                });

            } catch (error) {
                // This catch handles errors before the onAuthStateChanged listener starts (usually config parsing)
                console.error("FATAL FIREBASE SETUP ERROR:", error.message, error);
                document.getElementById('user-id-display').textContent = `ERROR: ${failureReason}`;
                showModal("Firebase Error", `Failed to initialize Firebase. Reason: ${failureReason}. Check console for details. Loading default roster.`);
                loadRosterData(true);
            }
        };

        // --- GAME DATA MANAGEMENT (FIRESTORE) ---

        /**
         * Gets the collection reference for public game data.
         * @param {string} appId - The application ID.
         */
        const getGamesCollectionRef = (appId) => {
            // Public data path: /artifacts/{appId}/public/data/hockey_lineups_shot
            return collection(db, `artifacts/${appId}/public/data/hockey_lineups_shot`);
        };

        /**
         * Sets up the real-time listener for all saved games.
         * @param {string} appId - The application ID.
         */
        const setupGameListener = (appId) => {
            if (!isAuthReady || !db) {
                if (masterRoster.length === 0) {
                    loadRosterData(true);
                }
                return;
            }

            const gamesQuery = query(getGamesCollectionRef(appId));

            onSnapshot(gamesQuery, (snapshot) => {
                allGames = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderGameSelector();
                console.log("Loaded all game templates:", allGames.length);
                if (allGames.length > 0) {
                    // Load the first saved game or the currently selected one
                    if (!currentGameId || !allGames.some(g => g.id === currentGameId)) {
                        selectGame(allGames[0].id);
                    } else {
                        selectGame(currentGameId); // Re-select to update data
                    }
                } else {
                    // If no saved games, initialize with a new game and the default roster
                    if (masterRoster.length === 0) {
                        loadRosterData(true);
                    }
                    if (!currentGameId) {
                        createNewGame();
                    } else {
                        renderAll(); // If game ID exists but no remote data, just render local
                    }
                }
            }, (error) => {
                console.error("Error fetching games:", error);
                // If a connection was made but the query failed (e.g., security rules), show a specific error
                showModal("Data Fetch Error", "Failed to fetch saved games. This is often caused by Firebase security rules not allowing read access.");
                loadRosterData(true);
            });
        };

        /**
         * Saves the current lineup state to Firestore.
         */
        window.saveGame = async () => {
            // Re-check app ID here to ensure we use the correct collection path
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            if (!currentGameId || !isAuthReady || !db) {
                showModal("Save Error", "The app is not fully initialized. Please wait a moment and ensure you have parsed a roster and selected a game.");
                return;
            }

            const gameSelector = document.getElementById('game-selector');
            const selectedOption = gameSelector.querySelector(`option[value="${currentGameId}"]`);
            const gameName = selectedOption ? selectedOption.textContent : `Game ${currentGameId.substring(0, 8)}`;

            const gameData = {
                id: currentGameId,
                name: gameName,
                masterRoster: masterRoster,
                lineup: currentLineup,
                availableRoster: availableRoster,
                updatedBy: userId,
                updatedAt: new Date().toISOString()
            };

            try {
                // Use the dynamically determined appId for the doc reference
                const gameDocRef = doc(db, `artifacts/${appId}/public/data/hockey_lineups_shot`, currentGameId);
                await setDoc(gameDocRef, gameData);
                showModal("Success!", `Lineup "${gameData.name}" saved successfully.`);
            } catch (error) {
                console.error("Error saving game:", error);
                showModal("Save Error", "Failed to save the lineup. This might be due to incorrect Firebase setup or security rules.");
            }
        };

        /**
         * Creates and selects a new, empty game template.
         */
        window.createNewGame = () => {
            const newGameId = generateUUID();
            const timestamp = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            const newGameName = `New Game - ${timestamp}`;

            // Reset state to a new, empty lineup but keep the current master roster data
            currentGameId = newGameId;
            currentLineup = {
                forwards: Array(4).fill(null).map(() => ([
                    {role: 'Left Forward', roleId: 'LF', player: null},
                    {role: 'Center Forward', roleId: 'CF', player: null},
                    {role: 'Right Forward', roleId: 'RF', player: null}
                ])),
                defense: Array(3).fill(null).map(() => ([
                    {role: 'Left Defense', roleId: 'LD', player: null},
                    {role: 'Right Defense', roleId: 'RD', player: null}
                ])),
                goalie: {role: 'Goalie', roleId: 'G', player: null}
            };
            availableRoster = [...masterRoster];

            // Add new option to selector and select it (locally)
            const newGameData = { 
                id: newGameId, 
                name: newGameName, 
                masterRoster: masterRoster, 
                lineup: currentLineup, 
                availableRoster: availableRoster 
            };
            allGames.push(newGameData);
            renderGameSelector();
            gameSelectorEl.value = newGameId;
            selectGame(newGameId); // This will re-render

            // Only show modal if triggered manually, not on initial load
            if (masterRoster.length > 0) {
                showModal("Game Created", `A new game template titled "${newGameName}" has been created locally. Remember to Save Lineup!`);
            }
        };

        /**
         * Loads the selected game template's data into the current state.
         * @param {string} id The game ID to select.
         */
        const selectGame = (id) => {
            const selectedGame = allGames.find(g => g.id === id);
            if (!selectedGame) {
                console.error("Game ID not found:", id);
                return;
            }

            // Update local state from loaded data
            currentGameId = selectedGame.id;
            masterRoster = selectedGame.masterRoster || [];
            currentLineup = selectedGame.lineup || currentLineup;
            availableRoster = selectedGame.availableRoster || [...masterRoster];

            // Update the roster text area
            if (masterRoster.length > 0) {
                // Reconstruct a simple CSV from the masterRoster for the textarea
                const rosterCSV = masterRoster.map(p => `${p.name},${p.number},${p.shot}`).join('\n');
                csvInputEl.value = "Name,Number,Shot\n" + rosterCSV;
            } else {
                 // Fallback if the saved game has no roster (shouldn't happen if saved correctly)
                csvInputEl.value = DEFAULT_ROSTER_CSV.trim();
            }

            renderAll();
            renderGameSelector(); // Ensure the selector reflects the choice
        };

        /**
         * Renders the options in the game selector dropdown.
         */
        const renderGameSelector = () => {
            gameSelectorEl.innerHTML = ''; // Clear previous options

            if (!allGames.some(g => g.id === currentGameId) && currentGameId) {
                // If a local game is active but not in the cloud list, add a local placeholder
                const localGame = { id: currentGameId, name: `[Local] Game ${currentGameId.substring(0, 8)}...` };
                allGames.push(localGame);
            }

            allGames.forEach(game => {
                const option = document.createElement('option');
                option.value = game.id;
                option.textContent = game.name;
                gameSelectorEl.appendChild(option);
            });

            if (currentGameId) {
                gameSelectorEl.value = currentGameId;
            }
        };

        // Event listener for game selection change
        gameSelectorEl.addEventListener('change', (event) => {
            selectGame(event.target.value);
        });

        // --- ROSTER/PLAYER MANAGEMENT (CSV LOADING & PARSING) ---
        
        /**
         * Core logic to parse CSV string into player objects.
         * @param {string} data - The CSV string.
         * @returns {boolean} True if players were successfully parsed.
         */
        const parseRoster = (data) => {
            if (!data) {
                masterRoster = [];
                return false;
            }

            // Split into lines, filter out empty lines
            const lines = data.trim().split('\n').filter(line => line.trim() !== '');

            // Skip the header row (assuming first line is "Name,Number,Shot")
            const playerLines = lines.slice(1);

            masterRoster = playerLines.map((line, index) => {
                // Safely split the line by comma, trim spaces
                const parts = line.split(',').map(p => p.trim());
                const [name, number, shot] = parts;
                
                return {
                    id: generateUUID(),
                    name: name || `Player ${index + 1}`,
                    number: number || '',
                    shot: shot ? shot.toUpperCase() : 'RH',
                    rosterKey: `${name}-${number}-${shot}` 
                };
            }).filter(p => p.name); // Filter out players without a name

            if (masterRoster.length > 0) {
                // Reset available roster based on the new master list
                availableRoster = [...masterRoster];

                // If a game is active, reset its lineup state based on the new roster keys
                if (currentGameId) {
                    currentLineup = {
                        forwards: Array(4).fill(null).map(() => ([
                            {role: 'Left Forward', roleId: 'LF', player: null},
                            {role: 'Center Forward', roleId: 'CF', player: null},
                            {role: 'Right Forward', roleId: 'RF', player: null}
                        ])),
                        defense: Array(3).fill(null).map(() => ([
                            {role: 'Left Defense', roleId: 'LD', player: null},
                            {role: 'Right Defense', roleId: 'RD', player: null}
                        ])),
                        goalie: {role: 'Goalie', roleId: 'G', player: null}
                    };
                }

                renderAll();
                return true;
            }
            return false;
        };

        /**
         * Loads roster data from the textarea (priority) or the configured Google Sheet URL (if textarea is empty).
         * This function is attached to the "Load Roster" button.
         * @param {boolean} isInitialLoad - If true, skips showing the modal.
         */
        window.loadRosterData = async (isInitialLoad = false) => {
            let rosterData = csvInputEl.value.trim();
            let source = "text input";

            if (!rosterData) {
                // If textarea is empty, attempt to fetch from URL
                if (GOOGLE_SHEET_URL.includes('PASTE_YOUR_PUBLISHED_CSV_LINK_HERE') || GOOGLE_SHEET_URL === '') {
                    // On initial load, use the fallback CSV if URL is still placeholder
                    rosterData = DEFAULT_ROSTER_CSV;
                    source = "default hardcoded list";
                    csvInputEl.value = rosterData.trim();
                } else {
                    // Fetch from URL
                    source = "Google Sheet URL";
                    if (!isInitialLoad) {
                        showModal("Loading...", "Fetching roster data from the published Google Sheet...");
                    }

                    try {
                        const response = await fetch(GOOGLE_SHEET_URL);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        rosterData = await response.text();
                        
                        // Set the fetched data into the textarea for display/editing
                        csvInputEl.value = rosterData.trim(); 
                        closeModal(); // Close loading modal
                        
                    } catch (error) {
                        console.error("Fetch Roster Error:", error);
                        showModal("Connection Error", "Failed to load the roster from the Google Sheet URL. Using the default roster.");
                        
                        // Fallback on failure
                        rosterData = DEFAULT_ROSTER_CSV; 
                        source = "default hardcoded list (after fetch failure)";
                        csvInputEl.value = rosterData.trim();
                    }
                }
            }

            // Now, parse the collected data
            if (parseRoster(rosterData)) {
                if (!isInitialLoad) {
                    showModal("Roster Loaded", `Successfully loaded ${masterRoster.length} players from the ${source}.`);
                }
            } else {
                showModal("Roster Error", `Failed to parse any players from the ${source}. Check the format (Name,Number,Shot).`);
            }
        };

        // --- RENDERING FUNCTIONS ---

        /**
         * Renders a single player card for the roster list.
         * @param {object} player - The player object.
         * @returns {string} The HTML string for the player card.
         */
        const createPlayerCard = (player) => {
            const shotClass = player.shot === 'LH' ? 'is-lh' : 'is-rh';
            const isGoalieClass = player.roleId === 'G' || player.name.toLowerCase().includes('goalie') ? 'is-goalie-type' : '';
            
            return `
                <div id="player-${player.id}"
                    class="player-card ${shotClass} ${isGoalieClass} p-3 rounded-lg border shadow-sm flex items-center justify-between text-sm"
                    draggable="true"
                    data-player-id="${player.id}"
                    data-roster-key="${player.rosterKey}"
                    ondragstart="handleDragStart(event)">
                    <span class="font-bold">${player.name}</span>
                    <span class="text-xs font-mono ml-2 p-1 rounded bg-white/50 border border-current">${player.number} / ${player.shot}</span>
                </div>
            `;
        };

        /**
         * Renders a single lineup slot.
         * @param {string} slotId - Unique ID for the slot (e.g., F1-LF).
         * @param {object} slot - The lineup slot object {role, roleId, player}.
         * @returns {string} The HTML string for the lineup slot.
         */
        const createLineupSlot = (slotId, slot) => {
            const playerCard = slot.player ? createPlayerCard(slot.player) : 
                `<div class="text-gray-400 text-center text-xs p-3">Drag player here</div>`;

            return `
                <div id="${slotId}"
                    class="lineup-slot p-2 rounded-lg border-2 border-dashed border-gray-300 bg-gray-50 hover:bg-gray-100 transition duration-150"
                    ondragover="handleDragOver(event)"
                    ondragleave="handleDragLeave(event)"
                    ondrop="handleDrop(event)">
                    <p class="text-xs font-semibold text-gray-600 mb-1">${slot.role}</p>
                    ${playerCard}
                </div>
            `;
        };

        /**
         * Renders the available roster list.
         */
        const renderRoster = () => {
            rosterListEl.innerHTML = availableRoster
                .map(player => createPlayerCard(player))
                .join('');
            rosterCountEl.textContent = availableRoster.length;
        };

        /**
         * Renders the forward lines.
         */
        const renderForwardLines = () => {
            forwardLinesEl.innerHTML = currentLineup.forwards.map((line, lineIndex) => {
                const lineNum = lineIndex + 1;
                const slotHTML = line.map(slot => 
                    createLineupSlot(`F${lineNum}-${slot.roleId}`, slot)
                ).join('');

                return `
                    <div class="p-4 border border-gray-200 rounded-lg bg-blue-50/50">
                        <h4 class="font-bold text-blue-700 mb-2">Line ${lineNum}</h4>
                        <div class="grid grid-cols-3 gap-3">
                            ${slotHTML}
                        </div>
                    </div>
                `;
            }).join('');
        };

        /**
         * Renders the defense pairings.
         */
        const renderDefenseLines = () => {
            defenseLinesEl.innerHTML = currentLineup.defense.map((pairing, pairIndex) => {
                const pairNum = pairIndex + 1;
                const slotHTML = pairing.map(slot => 
                    createLineupSlot(`D${pairNum}-${slot.roleId}`, slot)
                ).join('');

                return `
                    <div class="p-4 border border-gray-200 rounded-lg bg-green-50/50">
                        <h4 class="font-bold text-green-700 mb-2">Pairing ${pairNum}</h4>
                        <div class="grid grid-cols-2 gap-3">
                            ${slotHTML}
                        </div>
                    </div>
                `;
            }).join('');
        };

        /**
         * Renders the goalie slot.
         */
        const renderGoalieLine = () => {
            goalieLineEl.innerHTML = createLineupSlot('G1-G', currentLineup.goalie);
        };

        /**
         * Calls all rendering functions to refresh the UI.
         */
        const renderAll = () => {
            renderRoster();
            renderForwardLines();
            renderDefenseLines();
            renderGoalieLine();
        };

        // --- DRAG-AND-DROP HANDLERS ---

        let draggedPlayer = null;
        let originalSourceId = null;

        /**
         * Handles the start of a drag operation on a player card.
         */
        window.handleDragStart = (event) => {
            const playerId = event.target.dataset.playerId;
            draggedPlayer = masterRoster.find(p => p.id === playerId);
            originalSourceId = event.target.closest('.lineup-slot') ? event.target.closest('.lineup-slot').id : 'roster';
            
            event.dataTransfer.setData('text/plain', playerId);
            event.dataTransfer.effectAllowed = 'move';
            event.target.classList.add('opacity-50'); // Visual feedback
        };

        /**
         * Handles the drag over event on a lineup slot.
         */
        window.handleDragOver = (event) => {
            event.preventDefault(); // Allows drop
            event.dataTransfer.dropEffect = 'move';
            // Add a class for visual drag-over feedback
            event.currentTarget.classList.add('drag-over');
        };

        /**
         * Handles the drag leave event on a lineup slot.
         */
        window.handleDragLeave = (event) => {
            // Remove drag-over feedback
            event.currentTarget.classList.remove('drag-over');
        };

        /**
         * Handles the drop event on a lineup slot or the roster area.
         */
        window.handleDrop = (event) => {
            event.preventDefault();
            const dropTarget = event.currentTarget;
            dropTarget.classList.remove('drag-over');

            if (!draggedPlayer) return;

            // 1. Remove player from its original location (roster or lineup)
            removePlayer(draggedPlayer.id, originalSourceId);

            if (dropTarget.id === 'roster-list') {
                // Dropped back onto the Roster List
                placePlayerInRoster(draggedPlayer);
                showModal("Player Removed", `${draggedPlayer.name} is back in the available roster.`);
            } else {
                // Dropped onto a Lineup Slot
                const targetSlotId = dropTarget.id;
                
                // Check if the slot already contains a player
                const existingPlayer = getPlayerInLineupSlot(targetSlotId);

                if (existingPlayer) {
                    // If slot is occupied, move the existing player back to the roster
                    removePlayer(existingPlayer.id, targetSlotId);
                    placePlayerInRoster(existingPlayer);
                }

                // Place the new player in the target slot
                placePlayerInLineupSlot(targetSlotId, draggedPlayer);
                showModal("Line Change", `${draggedPlayer.name} placed at ${getRoleName(targetSlotId)}.`);
            }

            // 3. Clear state and re-render
            draggedPlayer = null;
            originalSourceId = null;
            renderAll();
        };

        /**
         * Cleans up after a drag operation finishes (e.g., removing the opacity class).
         */
        window.handleDragEnd = (event) => {
            event.target.classList.remove('opacity-50');
            // Ensure drag state is cleared if drop didn't fire (e.g., dropped outside a valid target)
            draggedPlayer = null; 
            originalSourceId = null;
        };
        document.addEventListener('dragend', window.handleDragEnd);


        // --- LINEUP STATE MUTATION HELPERS ---

        /**
         * Returns the friendly name of a role from its slot ID.
         * @param {string} slotId - The ID of the target slot.
         * @returns {string} The role name (e.g., "Left Forward").
         */
        const getRoleName = (slotId) => {
             const match = slotId.match(/([A-Z])(\d+)-([A-Z]+)/);
            if (!match) return "Unknown Slot";
            const [fullMatch, type, lineNum, roleId] = match;

            if (type === 'F') {
                return currentLineup.forwards[parseInt(lineNum) - 1].find(s => s.roleId === roleId)?.role || `${roleId} (Forward Line ${lineNum})`;
            } else if (type === 'D') {
                return currentLineup.defense[parseInt(lineNum) - 1].find(s => s.roleId === roleId)?.role || `${roleId} (Defense Pair ${lineNum})`;
            } else if (type === 'G') {
                return currentLineup.goalie.role;
            }
            return "Unknown Slot";
        };

        /**
         * Finds a player currently occupying a lineup slot.
         * @param {string} slotId - The ID of the target slot.
         * @returns {object|null} The player object or null.
         */
        const getPlayerInLineupSlot = (slotId) => {
            const match = slotId.match(/([A-Z])(\d+)-([A-Z]+)/);
            if (!match) return null;
            const [fullMatch, type, lineNum, roleId] = match;
            const lineIndex = parseInt(lineNum) - 1;

            if (type === 'F') {
                const slot = currentLineup.forwards[lineIndex]?.find(s => s.roleId === roleId);
                return slot ? slot.player : null;
            } else if (type === 'D') {
                const slot = currentLineup.defense[lineIndex]?.find(s => s.roleId === roleId);
                return slot ? slot.player : null;
            } else if (type === 'G') {
                return currentLineup.goalie.player;
            }
            return null;
        };

        /**
         * Removes a player from either the lineup or the available roster.
         * @param {string} playerId - The ID of the player to remove.
         * @param {string} sourceId - The ID of the slot or 'roster'.
         */
        const removePlayer = (playerId, sourceId) => {
            if (sourceId === 'roster') {
                // Remove from available roster list
                availableRoster = availableRoster.filter(p => p.id !== playerId);
            } else {
                // Remove from a lineup slot
                const match = sourceId.match(/([A-Z])(\d+)-([A-Z]+)/);
                if (!match) return;
                const [fullMatch, type, lineNum, roleId] = match;
                const lineIndex = parseInt(lineNum) - 1;

                if (type === 'F') {
                    const roleIndex = currentLineup.forwards[lineIndex].findIndex(s => s.roleId === roleId);
                    if (roleIndex !== -1) {
                        currentLineup.forwards[lineIndex][roleIndex].player = null;
                    }
                } else if (type === 'D') {
                    const roleIndex = currentLineup.defense[lineIndex].findIndex(s => s.roleId === roleId);
                    if (roleIndex !== -1) {
                        currentLineup.defense[lineIndex][roleIndex].player = null;
                    }
                } else if (type === 'G') {
                    currentLineup.goalie.player = null;
                }
            }
        };

        /**
         * Places a player back into the available roster.
         * @param {object} player - The player object to place.
         */
        const placePlayerInRoster = (player) => {
            // Only add if not already present (prevent duplicates, though drag/drop logic should prevent this)
            if (!availableRoster.some(p => p.id === player.id)) {
                availableRoster.push(player);
                // Sort by name for consistency
                availableRoster.sort((a, b) => a.name.localeCompare(b.name));
            }
        };

        /**
         * Places a player into a lineup slot.
         * @param {string} slotId - The ID of the target slot.
         * @param {object} player - The player object to place.
         */
        const placePlayerInLineupSlot = (slotId, player) => {
            const match = slotId.match(/([A-Z])(\d+)-([A-Z]+)/);
            if (!match) return;
            const [fullMatch, type, lineNum, roleId] = match;
            const lineIndex = parseInt(lineNum) - 1;

            if (type === 'F') {
                const roleIndex = currentLineup.forwards[lineIndex].findIndex(s => s.roleId === roleId);
                 if (roleIndex !== -1) {
                    currentLineup.forwards[lineIndex][roleIndex].player = player;
                }
            } else if (type === 'D') {
                const roleIndex = currentLineup.defense[lineIndex].findIndex(s => s.roleId === roleId);
                if (roleIndex !== -1) {
                    currentLineup.defense[lineIndex][roleIndex].player = player;
                }
            } else if (type === 'G') {
                currentLineup.goalie.player = player;
            }
        };

        // --- APPLICATION START ---

        // Set the default roster into the textarea on load (will be overwritten if URL fetch succeeds)
        csvInputEl.value = DEFAULT_RO
